<?php

/**
 * This file is part of the Flaphl package.
 * 
 * (c) Jade Phyressi <jade@flaphl.com>
 * 
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Flaphl\Element\Injection\Dumper;

use Flaphl\Element\Injection\ContainerBuilder;

/**
 * PHP dumper for exporting containers as compiled PHP classes.
 * 
 * Generates optimized PHP classes that can be cached and loaded
 * for maximum performance in production environments.
 * 
 * @package Flaphl\Element\Injection\Dumper
 * @author Jade Phyressi <jade@flaphl.com>
 */
class PhpDumper extends Dumper
{
    /**
     * Get the file extension for PHP files.
     * 
     * @return string The file extension without dot.
     */
    public function getFileExtension(): string
    {
        return 'php';
    }

    /**
     * Get the MIME type for PHP content.
     * 
     * @return string The MIME type.
     */
    public function getMimeType(): string
    {
        return 'text/x-php';
    }

    /**
     * Escape a string for use in PHP code.
     * 
     * @param string $string The string to escape.
     * @return string The escaped string.
     */
    protected function escape(string $string): string
    {
        return var_export($string, true);
    }

    /**
     * Perform the actual PHP dumping logic.
     * 
     * @param ContainerBuilder $container The container to dump.
     * @param array<string, mixed> $options Merged dumper options.
     * @return string The dumped container configuration.
     */
    protected function doDump(ContainerBuilder $container, array $options): string
    {
        $this->validateOptions($options);

        $code = $this->generateFileHeader($options);
        $code .= $this->generateClassDeclaration($options);
        $code .= $this->generateConstructor($container, $options);
        $code .= $this->generateParameterMethods($container, $options);
        $code .= $this->generateServiceMethods($container, $options);
        $code .= $this->generateHelperMethods($container, $options);
        $code .= "}\n";

        return $code;
    }

    /**
     * Generate the class declaration.
     * 
     * @param array<string, mixed> $options Dumper options.
     * @return string The class declaration code.
     */
    protected function generateClassDeclaration(array $options): string
    {
        $namespace = $options['namespace'];
        $className = $options['class'];
        $baseClass = $options['base_class'];

        $code = "<?php\n\n";
        
        if ($namespace) {
            $code .= "namespace {$namespace};\n\n";
        }

        if ($baseClass !== 'Flaphl\\Element\\Injection\\Container') {
            $code .= "use {$baseClass};\n\n";
            $baseClassName = substr(strrchr($baseClass, '\\'), 1);
        } else {
            $code .= "use Flaphl\\Element\\Injection\\Container;\n";
            $code .= "use Flaphl\\Element\\Injection\\ContainerInterface;\n\n";
            $baseClassName = 'Container';
        }

        $code .= "/**\n";
        $code .= " * This class has been auto-generated by the Flaphl Dependency Injection Element.\n";
        $code .= " */\n";
        $code .= "class {$className} extends {$baseClassName}\n{\n";

        return $code;
    }

    /**
     * Generate the constructor.
     * 
     * @param ContainerBuilder $container The container to dump.
     * @param array<string, mixed> $options Dumper options.
     * @return string The constructor code.
     */
    protected function generateConstructor(ContainerBuilder $container, array $options): string
    {
        $code = "    /**\n";
        $code .= "     * Constructor.\n";
        $code .= "     */\n";
        $code .= "    public function __construct()\n";
        $code .= "    {\n";
        $code .= "        parent::__construct();\n\n";

        // Initialize parameters
        foreach ($container->getParameterBag()->all() as $name => $value) {
            $escapedName = $this->escape($name);
            $escapedValue = $this->escape($value);
            $code .= "        \$this->setParameter({$escapedName}, {$escapedValue});\n";
        }

        $code .= "\n";

        // Register services
        foreach ($container->getDefinitions() as $id => $definition) {
            $escapedId = $this->escape($id);
            
            if ($definition->isShared()) {
                $code .= "        \$this->singleton({$escapedId}, [\$this, 'get{$this->camelize($id)}Service']);\n";
            } else {
                $code .= "        \$this->bind({$escapedId}, [\$this, 'get{$this->camelize($id)}Service']);\n";
            }
        }

        $code .= "    }\n\n";

        return $code;
    }

    /**
     * Generate parameter methods.
     * 
     * @param ContainerBuilder $container The container to dump.
     * @param array<string, mixed> $options Dumper options.
     * @return string The parameter methods code.
     */
    protected function generateParameterMethods(ContainerBuilder $container, array $options): string
    {
        $code = "";
        
        // If we want to inline parameters, generate getter methods
        if ($options['inline_factories']) {
            foreach ($container->getParameterBag()->all() as $name => $value) {
                $methodName = 'get' . $this->camelize($name) . 'Parameter';
                $escapedValue = $this->escape($value);
                
                $code .= "    /**\n";
                $code .= "     * Get the '{$name}' parameter.\n";
                $code .= "     * \n";
                $code .= "     * @return mixed\n";
                $code .= "     */\n";
                $code .= "    protected function {$methodName}(): mixed\n";
                $code .= "    {\n";
                $code .= "        return {$escapedValue};\n";
                $code .= "    }\n\n";
            }
        }

        return $code;
    }

    /**
     * Generate service factory methods.
     * 
     * @param ContainerBuilder $container The container to dump.
     * @param array<string, mixed> $options Dumper options.
     * @return string The service methods code.
     */
    protected function generateServiceMethods(ContainerBuilder $container, array $options): string
    {
        $code = "";

        foreach ($container->getDefinitions() as $id => $definition) {
            $methodName = 'get' . $this->camelize($id) . 'Service';
            $className = $definition->getClass();
            
            $code .= "    /**\n";
            $code .= "     * Get the '{$id}' service.\n";
            $code .= "     * \n";
            $code .= "     * @return {$className}\n";
            $code .= "     */\n";
            $code .= "    protected function {$methodName}(): {$className}\n";
            $code .= "    {\n";

            // Generate instantiation code
            $code .= "        \$instance = new {$className}(";
            
            $arguments = [];
            foreach ($definition->getArguments() as $argument) {
                $arguments[] = $this->dumpValue($argument);
            }
            
            $code .= implode(', ', $arguments);
            $code .= ");\n\n";

            // Generate property assignments
            foreach ($definition->getProperties() as $property => $value) {
                $code .= "        \$instance->{$property} = " . $this->dumpValue($value) . ";\n";
            }

            // Generate method calls
            foreach ($definition->getMethodCalls() as $call) {
                [$method, $methodArgs] = $call;
                $code .= "        \$instance->{$method}(";
                
                $dumpedArgs = [];
                foreach ($methodArgs as $arg) {
                    $dumpedArgs[] = $this->dumpValue($arg);
                }
                
                $code .= implode(', ', $dumpedArgs);
                $code .= ");\n";
            }

            $code .= "\n        return \$instance;\n";
            $code .= "    }\n\n";
        }

        return $code;
    }

    /**
     * Generate helper methods.
     * 
     * @param ContainerBuilder $container The container to dump.
     * @param array<string, mixed> $options Dumper options.
     * @return string The helper methods code.
     */
    protected function generateHelperMethods(ContainerBuilder $container, array $options): string
    {
        $code = "";

        if ($options['debug']) {
            $code .= "    /**\n";
            $code .= "     * Get debug information about this container.\n";
            $code .= "     * \n";
            $code .= "     * @return array<string, mixed>\n";
            $code .= "     */\n";
            $code .= "    public function getDebugInfo(): array\n";
            $code .= "    {\n";
            $code .= "        return [\n";
            $code .= "            'compiled_at' => " . $this->escape(date('Y-m-d H:i:s')) . ",\n";
            $code .= "            'container_hash' => " . $this->escape($this->generateHash($container)) . ",\n";
            $code .= "            'service_count' => " . count($container->getDefinitions()) . ",\n";
            $code .= "            'parameter_count' => " . count($container->getParameterBag()->all()) . ",\n";
            $code .= "        ];\n";
            $code .= "    }\n\n";
        }

        return $code;
    }

    /**
     * Dump a value to PHP code.
     * 
     * @param mixed $value The value to dump.
     * @return string The PHP code representation.
     */
    protected function dumpValue(mixed $value): string
    {
        if (is_string($value)) {
            // Handle service references
            if (str_starts_with($value, '@')) {
                $serviceId = substr($value, 1);
                return "\$this->get(" . $this->escape($serviceId) . ")";
            }

            // Handle parameter references
            if (str_starts_with($value, '%') && str_ends_with($value, '%')) {
                $paramName = substr($value, 1, -1);
                return "\$this->getParameter(" . $this->escape($paramName) . ")";
            }
        }

        return var_export($value, true);
    }

    /**
     * Convert a string to camelCase.
     * 
     * @param string $string The string to convert.
     * @return string The camelCase string.
     */
    protected function camelize(string $string): string
    {
        return str_replace(' ', '', ucwords(str_replace(['-', '_', '.'], ' ', $string)));
    }
}
